[
  {
    "objectID": "index.html",
    "href": "index.html",
<<<<<<< HEAD
    "title": "Apuntes",
    "section": "",
    "text": "Este block encontraras algunos apuntes de la clase de algebra lineal computacional"
=======
    "title": "nuevo",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
>>>>>>> dd8470f2706310706559b8fd01854da5870b8036
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Problemas que vamos a estudiar en el curso de Algebra Lineal # Espacios subespacios vectoriales"
  },
  {
    "objectID": "about.html#multiplicación-usando-columnas-ax",
    "href": "about.html#multiplicación-usando-columnas-ax",
    "title": "About",
    "section": "Multiplicación usando columnas \\(Ax\\)",
    "text": "Multiplicación usando columnas \\(Ax\\)"
  },
  {
    "objectID": "about.html#cuatro-espacios-vectoriales-fundamentales",
    "href": "about.html#cuatro-espacios-vectoriales-fundamentales",
    "title": "About",
    "section": "Cuatro espacios vectoriales fundamentales",
    "text": "Cuatro espacios vectoriales fundamentales"
  },
  {
    "objectID": "about.html#norma-de-vectores-matrices-y-funciones",
    "href": "about.html#norma-de-vectores-matrices-y-funciones",
    "title": "About",
    "section": "Norma de vectores, matrices y funciones",
    "text": "Norma de vectores, matrices y funciones\n\nk-mean clustering"
  },
  {
    "objectID": "about.html#pca",
    "href": "about.html#pca",
    "title": "About",
    "section": "PCA",
    "text": "PCA"
  },
  {
    "objectID": "section1.html",
    "href": "section1.html",
    "title": " Introducción a la álgebra lineal Computacional",
    "section": "",
    "text": "Existen tres tipos de variables numéricas float, complex y int\n\nfloat(5.0)\n\n5.0\n\n\n\nint(5.8)\n\n5\n\n\n\ncomplex(1,2)\n\n(1+2j)\n\n\n\n\n\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n+\nsuma\n\n\n*\nMultiplicación\n\n\n/\nDivisión de numeros flotantes\n\n\n//\nDivisión de números enteros\n\n\n%\nMódulo\n\n\n**\nExponencial\n\n\n\n\nprint(5%3)\n\n2\n\n\n\n(4.0+5.3j).imag\n\n5.3\n\n\nPara las operaciones matemáticas usted debe importar la libreria math la cual la debe importar con\n\nimport math as ma\n\n\nma.sqrt(4.0)\n\n2.0\n\n\nAqui podemos generar variables de la siguiente forma\n\na=2.0+6.2j\n\n\ntype(a) # con este comando puede usted ver que tipo de variable esta guardada\n\ncomplex\n\n\nPodemos comprara variables y numéros con los siguientes comando\n\n\n\nSimbolos\nOperaciones\n\n\n\n\n==\nigual\n\n\n!=\ndiferente\n\n\n<\nmenor que\n\n\n<=\nmenor igual que\n\n\n\\(>\\)\nmayor que\n\n\n\\(>=\\)\nmayor e igual que\n\n\n\n\n4==4.0\n\nTrue\n\n\n\n\n\nLos operadores lógicos en Python son >and\n>or >not\nQue diferencia existe con la siguiente sintaxis >from math import *\ny\n\nimport math"
  },
  {
    "objectID": "section1.html#ejemplos-adicionales",
    "href": "section1.html#ejemplos-adicionales",
    "title": " Introducción a la álgebra lineal Computacional",
    "section": "Ejemplos adicionales",
    "text": "Ejemplos adicionales\n\nlista_de_colores = ['rojo', 'verde', 'azul', 'blanco']\nfor color in lista_de_colores:\n    for letra in color:\n        print(letra,end='.')\n    print()\n\nr.o.j.o.\nv.e.r.d.e.\na.z.u.l.\nb.l.a.n.c.o."
  },
  {
    "objectID": "section1.html#if",
    "href": "section1.html#if",
    "title": " Introducción a la álgebra lineal Computacional",
    "section": "If",
    "text": "If\nLa sintanxis del es\n\nif < logical expression 1 >:\n\n\n<statements 1 >\n\n\nelif < logical expression 2 >:\n\n\n<statements 2 >\n\n\n…\n\n\nelse:\n\n\n\n\nLa sintaxis de if es similar a la de otros lenguajes de programación\n\nfor x in range(10):\n    if x <= 3:\n        print(x, 'is less than or equal to three ')\n    elif x ==5 or x ==6:\n        print(x, 'is greater than five ')\n    else:\n        print(x, 'must be four or five , then ')\n       \n\n0 is less than or equal to three \n1 is less than or equal to three \n2 is less than or equal to three \n3 is less than or equal to three \n4 must be four or five , then \n5 is greater than five \n6 is greater than five \n7 must be four or five , then \n8 must be four or five , then \n9 must be four or five , then"
  },
  {
    "objectID": "section1.html#continue",
    "href": "section1.html#continue",
    "title": " Introducción a la álgebra lineal Computacional",
    "section": "continue",
    "text": "continue\nContinue es un estamento similar a break, pero en lugar de salir del ciclo que esta contenido en el bucle, este fuerza a la nueva iteración del bucle sin completar las intrucciones del bloque de la actual iteración\n\nfor i in range(1, 11):\n    if i % 2:\n        continue\n    print(i, 'is even!')\n\n2 is even!\n4 is even!\n6 is even!\n8 is even!\n10 is even!"
  },
  {
    "objectID": "section1.html#pass",
    "href": "section1.html#pass",
    "title": " Introducción a la álgebra lineal Computacional",
    "section": "pass",
    "text": "pass\nEl comando de paso no hace nada. Es útil como un “código auxiliar” para el código que aún no se ha escrito, pero donde una declaración se equipara sintácticamente con los espacios en blanco de Python.\n\nfor i in range(1, 11):\n    if i == 6:\n        pass # do something special if i is 6\n    if not i % 3:\n        print(i, 'is divisible by 3')\n\n3 is divisible by 3\n6 is divisible by 3\n9 is divisible by 3"
  },
  {
    "objectID": "section1.html#definición-de-funciones",
    "href": "section1.html#definición-de-funciones",
    "title": " Introducción a la álgebra lineal Computacional",
    "section": "Definición de funciones",
    "text": "Definición de funciones\nPara definir una función en Python es necesario tres partes, encabezado, cuerpo y retorno. Para llamar la función debemos usar el encabezado. Ejemplo\n\ndef cuadrado( ):   # encabezado de la función\n    x=8\n    x_cuadrado=x**2 # cuerpo\n    return x_cuadrado #retorno  \n## llamar la función \ns=cuadrado()\nprint(s)\n\n64\n\n\nPuede ser más de un argumetno que se ingresa en la función, ya sea listas, tuplas o string\n\ndef ejemplo(x,a,s):\n    print(x[0],a[1],s)\n    return x[1], s[0]\nx=[1,2.3]\na=(2,5.2,6)\ns='hola'\na,u=ejemplo(x,a,s)\nprint(u)\n\n1 5.2 hola\nh\n\n\nEn phyton es posible pasar los argumentos en desorden de la siguiente forma\n\ndef ejemplo(x, a, s):\n    print(x[0], a[1], s)\n    return\n\n\np = [1, 2.3]\nh = (2, 5.2, 6)\nf = 'hola'\nejemplo(s=f, x=p, a=h)\n\n1 5.2 hola\n\n\nCaundo se quiere haccer una programación modulada, es decir crear varios archivos o fichero, lo cual ayuda a la manotención estas se deben importar\n\nFichero 1 # Fibonacci numbers module\n\n\ndef fib(n): # write Fibonacci series up to n\n\n\na, b = 0, 1\n\n\nwhile a < n:\n\n\n   print(a, end=' ')\n\n\n   a, b = b, a+b\n\n\nprint()\n\n\ndef fib2(n): # return Fibonacci series up to n\n\n\nresult = []\n\n\na, b = 0, 1\n\n\nwhile a < n:\n\n\n   result.append(a)\n\n\n   a, b = b, a+b\n\n\nreturn result"
  },
  {
    "objectID": "section3.html",
    "href": "section3.html",
    "title": "Espacios vectoriales",
    "section": "",
    "text": "Sea \\(V\\) un conjunto de elementos (estos elementos serán llamados vectores), y \\(F\\) un campo (en nuestro caso serán los números reales o complejos, es llamado un espacio vectorial si satisface los siguientes axiomas\n\nClausuraAdición.Multiplicación.\n\n\n\nSi \\(x,y\\in V\\) entonces existe un único \\(z\\in V\\) tal que \\(x+y=z\\).\nSi \\(a\\in F\\) y \\(x\\in V\\) entonces existe un único \\(z\\in V\\) tal que \\(z=ax\\).\n\n\n\nSi \\(x,y,z \\in V\\) y \\(a\\in F\\)\n\n\\(x+y=y+x\\)\n\\((x+y)+z=x+(y+z)\\)\nExistencia del cero Existe un elemento en \\(V\\) denotado por \\(0_V\\) tal que\n\\(x+0_V=x\\) (note que e muchas veces se tomara por notación \\(0\\) en vez de \\(=_V\\))\nExistencia de opuesto, Para todo \\(x\\in V\\) existe un elemento \\(y\\in V\\) tal que\n\\(x+y=0_V\\). Este elemento sera denotado por \\(-x=y\\)\n\n\n\nSi \\(x,y,z \\in V\\) y \\(a,b\\in F\\)\n\n\\(a(bx)=(ab)x\\)\n\\(a(x+y)=ax+ay\\)\n\\((a+b)x=ax+bx\\)\nPara todo \\(x\\in V\\) tenemos \\(1x=x\\)\n\n\n\n\n\n\n\n\\(\\mathcal{R}̣\\)\n\\(\\mathcal{C}\\)\n\\(\\mathcal{R}^n\\)\n\\(\\mathcal{C}^n\\)\nEl conjunto de todos los vectores ortogonales a un vector dado\nEl conjunto de todas las funciones definidas en \\(\\mathcal{R}\\)\nEl conjunto de todas las funciones continuas en un intervalo dado\nEl conjunto de todas las matrices del mismo tamaño\nEl conjunto de todas las funciones diferenciables en un intervalo dado\nEl conjunto de todas las funciones que satisfacen la ecuación diferencial \\[y''+ay'+by.\\]\n\n\n\nSea \\(V\\) un espacio vectorial y \\(S\\) un subconjunto de \\(V\\), \\(S\\) es un subespacio de \\(V\\), si en si mismo es un espacio vectorial.\n\n\n\n\n\n\nTeorema\n\n\n\nSea \\(S\\) un subconjunto no vació de un espacio vectorial \\(V\\). Si los elementos de \\(S\\) satisfacen los axiomas de clausura entonces \\(S\\) es un subespacio de \\(V\\)\n\n\n\n\n\n\n\n\nDefinición\n\n\n\nSea \\(S\\) un subconjunto no vació de un espacio vectorial \\(V\\), un elemento \\(x\\) de \\(V\\) de la forma: \\[x=\\sum_{i=1}^{k}c_ix_i,\\] en donde \\(x_1,x_2,...,x_k\\) son elementos de \\(S\\) y \\(c_i\\) son escalares, se denomina la combinación lineal de elementos de \\(S\\).\n\n\n\n\n\n\n\n\nTeorema\n\n\n\nEl conjunto \\(span(S)=\\{\\sum_{i=1}^{k}c_ix_i,|c_i\\in F\\}\\) de todos los elementos generados en combinación lineal de \\(S\\) es un subespacio vectorial de \\(V\\)\n\n\n\n\n\n\n\n\nNote\n\n\n\nSi \\(S\\) es un subespacio de \\(V\\) entonces \\(S=span(S)\\). Además, el generado \\(gen(S)=span(S)\\)\n\n\nSupongamos que queremos calcular el \\(span(S)\\) donde \\(S\\{x_1,x_2,...,x_n\\}\\), y \\(x_i\\in\\mathbb{R^n}\\), para esto debemos calcular todas las combinaciones lineales de los elementos de \\(S\\) de la siguinete forma\n\\[span(S)=\\{\\sum_{i=1}^{n}c_ix_i,|c_i\\in\\mathbb{R}\\}\\]\nOtra forma de calcular esta combinación es crear una matriz \\(M\\) con todos los vectores de \\(S\\) y multiplicarla por un vector columna de los coeficientes \\(c_i\\), de esta forma obtenemos un vector columna con todos los elementos de la combinación lineal, esto se puedo expresar como la multiplicación de una matriz por un vector columna.\n\\[span(S)=M\\in\\mathbb{R}c\\]\n\n\n\n\n\n\nDefinición\n\n\n\nSea \\(A\\) una matriz de \\(m\\times n\\), definimos como \\(Im(A)=span\\{y\\in\\mathbb{R^m}|Ax=y\\}\\), note si tomamos \\(x=e_i\\) tenemos donde \\(Ae_i=A_i\\) son las columnas de \\(A\\). Además definimos \\(Ker(A)=\\{x\\in\\mathbb{R^n}|Ax=0\\}\\)."
  },
  {
    "objectID": "ejercicio.html",
    "href": "ejercicio.html",
    "title": "Ejercicios",
    "section": "",
    "text": "Problemas\n\nEn el espacio vectorial real \\(C(1,e)\\), definimos la función \\(<f,g>=\\int_1^e(\\log x)(f(x)g(x))\\, dx\\)\n\nPruebe que esta función es un producto interno\nSi \\(f(x)=\\sqrt{x}\\), calcular \\(||f||\\)\nHallar el polinomio de primer grado \\(ax+b\\) que sea ortogonal a la función constante \\(f(x)=1\\)\n\nEn el espacio vectorial de todas las funciones polinómicas reales, determinar si \\[<f,g>=\\int_0^1f'(x)g'(x)\\, dx.\\] es o no un producto interno. En el caso que \\(<f,g>\\) no es un producto interno, indicar que axiomas no son respetados y el por que. \\(f'\\) y \\(g'\\) indican derivadas.\nEn espacio vectorial de todos los polinomios reales, con producto interno \\(<x,y>=\\int_0^1x(t)y(t)\\,dt\\), sea \\(x_n=t^n\\) para \\(n=0,1,2,...\\). Demostrar que las funciones\n\n\\[y_0(t)=1,\\quad\\, \\, y_1(t)=\\sqrt{3}(2t-1),\\quad\\,\\,y_2(t)=\\sqrt{5}(6t^2-6t+1)\\]\nforman un conjunto ortogonal que generan el mismo subespacio que \\(\\{x_0,x_1,x_2\\}\\)\n\nSea \\(\\mathbb{R}^n\\) un espacio vectorial, Compruebe o refute si las siguientes relaciones forman un producto interno::\n\n\\(x \\cdot y = \\sum_{i=1}^ne^{2} x_i y_i\\)\n\\(x \\cdot y =x_1y_1 − x_1y_2 − x_2y_1 +\\alpha x_2y_2\\), para \\(n=2\\) y \\(\\alpha \\in \\mathbb{R}\\)\n\\(x \\cdot y = \\sum_{i=1}^{n/2} x_{2i} y_{2i} -\\sum_{i=1}^{n/2} x_{2i-1} y_{2i-1}\\)\n\nDenuestre que si \\(V\\) y \\(W\\) son dos subespacios ortogonales de un espacio vectorial \\(E\\), entonces \\(V\\cap W=0\\)\nEncuentre un vector \\(x\\) ortogonal al espacio de filas de \\(A\\), y un vector \\(y\\) ortogonal al espacio de columnas, y un vector \\(z\\) ortogonal al nulo de \\(A\\): \\[A=\\begin{bmatrix} 1 & 2 & 1 \\\\ 2 & 4 & 3 \\\\ 3 & 6 & 4 \\end{bmatrix}\\]\nMuestre que si \\(x-y\\) es ortogonal a \\(x+y\\), si y solo si \\(||x||=||y||\\)\nSea \\(P\\) un plano en \\(\\mathbb{R}^2\\) con ecuación \\(x+2y-z=0\\). Encuentre un vector unitario perpendicular a \\(P\\).¿Cual es la matriz que tiene el plano \\(P\\) como su espacio nulo?, y cual matriz tiene \\(P\\) como su espacio columna?\nCual de los siguientes estamentos son falsos\n\nSi \\(V\\) es ortogonal a \\(W\\), entonces \\(V^{\\perp}\\) es ortogonal a \\(W^{\\perp}\\)\nSi es ortogonal a \\(W\\), y \\(W\\) es ortogonal a \\(Z\\), entonces \\(V\\) es ortogonal a \\(Z\\)"
  },
  {
    "objectID": "section2.html",
    "href": "section2.html",
    "title": " Introducción a la álgebra lineal Computacional",
    "section": "",
    "text": "Una de la parte más importante en la programación cientíica son las graficas que podemos producir con nuestros algoritmos. En este aparte daremos una pequeña introducción a este tema usando dos librerias: matplotlib y numpy para importar estas librerías usamos\n\nimport matplotlib.pyplot as plt\nimport  numpy as np\n\n\n\n\nax=[0.,0.5,1.0,1.5,2.0,2.5,3.0]\nby=[0.0,0.25,1.0,2.25,4.0,6.25,9.0]\nplt.plot(ax,by)\nplt.show()\n\n\n\n\n\nimport random\nax, ay = [], []\nfor i in range(100):\n    ax.append(random.random())\n    ay.append(random.random())\nplt.scatter(ax, ay)\nplt.show()\nplt.savefig('plot.png')\n\n\n\n\n<Figure size 432x288 with 0 Axes>\n\n\n\n\n\npara guardas estas gráficas podemos usar los siguientes comando\n\n\nplt.savefig('plot.pdf')\nplt.savefig('plot.eps')\n\n<Figure size 432x288 with 0 Axes>"
  },
  {
    "objectID": "section4.html",
    "href": "section4.html",
    "title": "Subespacios principales de una matriz",
    "section": "",
    "text": "Una matriz \\(A_{m\\times n}\\) crea cuatro subespacios importantes, como los podemos mostrar en la siguiente figura. (Aquí se puede encontrar màs inforacion del tema)\n\n\n\n4 espacios fundamentales\n\n\nLlamaremos \\(C(A)\\) como el espacio columna de la matriz \\(A\\) y \\(N(A)\\) como el espacio nulo de la matriz de \\(A\\). De aquì podemos observar las siguientes propiedades\n\\[C(A^T)\\perp N(A).\\] Para mostrar esta proiedad debemos mostrar que si \\(x_1\\in C(A^T)\\) y \\(x_2\\in N(A)\\), entonces\n\\[\\langle x_1,x_2\\rangle=x_2^Tx_1=0.\\]\nSabemos que existe un \\(y\\in \\mathbb{R}^m\\), note que lo podemos descomponer en \\(y=y_1+y_2\\), donde \\(y_1\\in C(A)\\) y \\(y_2\\in N(A^T)\\) luego \\[A^Ty=A^T(y_1+y_2)=A^ty_1=x_1.\\]\nAhora tenemos que\n\\[\\langle x_2,x_1\\rangle=(A^Ty)^Tx_2=y^TAx_2=0,\\] por tanto son ortogonales. Con un argumento similar podemos mostrar que \\(C(A)\\perp N(A^T)\\).\nAdemas tenemos la propiedad que \\[dim(C(A))=dim(N(A^T))=r,\\] de esta forma tenemos que \\(dim(N(A))=n-r\\) y \\(dim(N(A^T))=m-r\\).\n\n\n\n\n\n\nDefinición\n\n\n\nSea \\(A\\) una matriz de \\(m\\times n\\), definimos como el \\(rank(A)\\) como el numero máximo de filas o columnas lienalmente independientes de \\(A\\). Note que por la propiedad anterior tenemos que \\(rank(A)=dim(C(A))=dim(N(A^T))\\).\n\n\n\n\n\n\n\n\nDefinición\n\n\n\nSea \\(A\\) una matriz de \\(m\\times n\\), con \\(m>n\\) \\(rank(A)=n\\) diremos que \\(A\\) es una matriz de rango completo.\n\n\nAlgunas propiedades importantes del rank son las siguientes\n\nSi \\(A\\) es una matriz cuadrada y \\(rank(A)=n\\) entonces todos autovalores de \\(A\\) son distintos de cero.\nSi \\(A\\) es una matriz cuadrada entonces \\(rank(A)=n\\) si y solo si \\(A\\) es invertible.\n\nPara demostrar la primera vamos a suponer que es falso por tanto 0 es un autovalor luego \\(Ax=0\\), lo que implica que \\(N(A)\\neq\\emptyset\\), esto contradice el hecho que \\(rank(A)=dim(C(A^T))=dim(C(A))=n\\). Ahora, si \\(A\\) tiene todos los autovalores diferentes de cero entonces \\(A\\) es invertible, por lo tanto \\(rank(A)=n\\).\n\nSi \\(A\\) una matriz de \\(m\\times n\\), con \\(m>n\\) entonces \\(A^TA\\) es invertible.\n\nSea \\(x\\in \\mathbb{R}^n\\) entonces \\(Ax=y\\neq 0\\) puesto que \\(rank(A)=n,\\) entonces \\(y\\notin N(A^T)\\). De esta forma existe un \\(x\\neq 0\\) tal que \\(x=A^Ty\\) y que \\(x\\in C(A^T)\\) y \\(x\\neq 0\\). Para completar la demostración debemos debemos mostrar que \\(dim(Im(A^TA))=n\\).\nPara esto vamos a usar la propiedad que \\(rank(A)=n\\) y \\(rank(A^T)=n\\). Entonces tenemos que \\(rank(A^TA)=n\\) y por lo tanto \\(A^TA\\) es invertible."
  },
  {
    "objectID": "section4.html#definición",
    "href": "section4.html#definición",
    "title": "Untitled",
    "section": "Definición",
    "text": "Definición\nSea \\(A\\) una matriz de \\(m\\times n\\), definimos como el \\(rank(A)\\) como el numero máximo de filas o columnas lienalmente independientes de \\(A\\). Note que por la propiedad anterior tenemos que \\(rank(A)=dim(C(A))=dim(N(A^T))\\).\n:::"
  },
  {
    "objectID": "section6.html",
    "href": "section6.html",
    "title": "Factorización QR",
    "section": "",
    "text": "El método de Gram schmid consiste en tomar un conjunto de vectores linealmete independientes y construir un conjunto de vectores ortogonales a partir de ellos. Para ello se toma el primer vector y se normaliza, luego se toma el segundo vector y se le resta la proyección de este sobre el primero, luego se normaliza y se repite el proceso con el tercer vector y así sucesivamente. El resultado es un conjunto de vectores ortogonales que son linealmente independientes.\nEl método de Gram schmid es un método iterativo que se puede expresar de la siguiente manera: sea \\(A_1, A_2, \\dots, A_n\\) un conjunto de vectores linealmente independientes, entonces se define el conjunto de vectores ortogonales \\(u_1, u_2, \\dots, u_n\\) de la siguiente manera: \\[u_1 = \\frac{A_1}{\\|A_1\\|},\\] \\[\\overline{u}_2 = A_2 - \\langle u_1, A_2 \\rangle u_1,\\] \\[u_2=\\|\\overline{u}_2 \\|,\\] \\[\\overline{u}_3 = A_3 -\\sum_{j=1}^2 \\langle u_j, A_3 \\rangle u_j, \\] \\[u_3=\\|\\overline{u}_3 \\|,\\] \\[\\vdots\\] \\[\\overline{u}_n = A_n  -\\sum_{j=1}^{n-1} \\langle u_j, A_n \\rangle u_j, \\]\n\\[u_n=\\|\\overline{u}_n \\|.\\]\nAhora si escribimos una matriz \\(A\\) de \\(m\\times n\\), con \\(m>n\\) formada por los vectores \\(A_1, A_2, \\dots, A_n\\) como columnas. Note que $rank(A)=n vamos a reproducir el proceso anterior, pero ahora en forma matricial.\n\\[y_1=A_1, \\text{ y } q_1=\\frac{y_1}{\\|y_1\\|},\\] ahora para encontrar el segundo vector \\(y_2\\) se tiene que: \\[y_2=A_2-q_1(q_1^TA_2), \\text{ y } q_1=\\frac{y_1}{\\|y_1\\|},\\]\ny así sucesivamente hasta encontrar \\(y_n\\) y \\(q_n\\). \\[y_n=A_n-\\sum_{j=1}^{n-1} q_j(q_j^TA_n), \\text{ y } q_n=\\frac{y_n}{\\|y_n\\|}.\\]\nNote que de esta forma podemos escribir \\(A\\) como:\n\\[A_1=r_{11}q_1,\\] \\[A_2=r_{21}q_1+r_{22}q_2,\\] y \\[ A_n=r_{n1}q_1+r_{n2}q_2+r_{n3}q_3+\\dots+r_{nn}q_n.\\]\nDe esta forma podemos escribir \\(A\\) como el producto de dos matrices \\(Q\\) y \\(R\\) donde \\(Q\\) es una matriz ortogonal y \\(R\\) es una matriz triangular superior.\n\\[A=[A_1|A_2|...|A_n]=[q_1|q_2|...|q_n]\\begin{bmatrix}\nr_{11} & r_{12} & ...&r_{1n}\\\\\n& r_{12} & ...&r_{1n}\\\\\n&  &\\ddots&\\vdots\\\\\n& & ...&r_{nn}\\\\\n\\end{bmatrix}\\]\nEste procedimeinto se llama la factorización QR de \\(A\\).\nahora vamos a probar el método con una matriz aleatoria de \\(m\\times n\\) con \\(m>n\\).\nMétodo de Gram-Schmidt modificado\nEl método de Gram-Schmidt modificado es una variación del método de Gram-Schmidt. En este método se toma el primer vector y se normaliza, luego se toma el segundo vector y se le resta la proyección de este sobre el primero, luego se normaliza y se repite el proceso con el tercer vector y así sucesivamente. El resultado es un conjunto de vectores ortogonales que son linealmente independientes. El método de Gram-Schmidt modificado es un método iterativo que se puede expresar de la siguiente manera:"
  },
  {
    "objectID": "section6.html#pregunta",
    "href": "section6.html#pregunta",
    "title": "Factorización QR",
    "section": "Pregunta",
    "text": "Pregunta\n¿Qué podemos decir de las filas de la matriz de \\(Q\\) si \\(A_{n\\times m}\\) con \\(n>m\\)? ¿ De los productos \\(Q^tQ\\) y \\(QQ^T\\)?"
  },
  {
    "objectID": "section5.html",
    "href": "section5.html",
    "title": "Minímos cuadrados 1",
    "section": "",
    "text": "Sea \\(A\\) una matriz de \\(m\\times n\\) y \\(b\\) un vector de \\(\\mathbb{R}^m\\). El problema de mínimos cuadrados es encontrar \\(\\overline{x}\\in \\mathbb{R}^n\\) tal que \\[mim_{\\overline{x}}\\|A\\overline{x}-y\\|_2.\\] Para encontrar esto podemos usar el teorema de la proyección ortogonal. Sea \\(y\\in \\mathbb{R}^m\\) y \\(N(A^T)\\) el espacio nulo de \\(A^T\\) y \\(C(A)\\) el espacio columna de \\(A\\). Entonces\nSea \\(y\\in \\mathbb{R}^m\\) luego \\(y=y_1+y_2\\) con \\(y_1\\in N(A^T)\\) y \\(y_2\\in C(A)\\) entonces\n\\[A^Ty=A^T(y_1+y_2)=A^Ty_1+A^Ty_2=A^Ty_2,\\]\ncomo \\(y_2\\in C(A)\\) entonces existe un \\(\\overline{x}\\) tal que \\[A\\overline{x}=y_2,\\] sustituyendo en la primera ecuación tenemos que \\[A^TA\\overline{x}=A^Ty.\\]\nComo \\(A^TA\\) es simétrica y e invertible tenemos que \\[\\overline{x}=(A^TA)^{-1}A^T y.\\]\nEjemplo\nSupongamos que tenemos un sistema de tres ecuaciones y dos incognitas como el siguiente \\[\\begin{cases}x_1+x_2=2\\\\\nx_1-x_2=1\\\\\nx_1+x_2=3\\end{cases},\\] este sistema lo podemos escribir en forma matricial \\(Ax=b\\) de la siguiente forma\n\\[\\begin{bmatrix}1&1\\\\1&-1\\\\1&1\\end{bmatrix}\\begin{bmatrix}x_1\\\\x_2\\end{bmatrix}=\\begin{bmatrix}2\\\\1\\\\3\\end{bmatrix}.\\]\nNote que esto lo podemos escribir como\n\\[\\begin{bmatrix}1\\\\1\\\\1\\end{bmatrix}x_1+\\begin{bmatrix}1\\\\-1\\\\1\\end{bmatrix}x_2=\\begin{bmatrix}2\\\\1\\\\3\\end{bmatrix}.\\]\nDe esta forma lo que queremos es encontrar la proyección del vertor \\(\\begin{bmatrix}2\\\\1\\\\3\\end{bmatrix}\\) en el generado por el conjunto de vectores \\[\\Big\\{\\begin{bmatrix}1\\\\1\\\\1\\end{bmatrix},\\begin{bmatrix}1\\\\-1\\\\1\\end{bmatrix}\\Big\\},\\]\nGráficamente lo podemos interpretar como muestra la siguiente gráfica"
<<<<<<< HEAD
  },
  {
    "objectID": "compu.html",
    "href": "compu.html",
    "title": "Untitled",
    "section": "",
    "text": "Existen tres tipos de variables numéricas float, complex y int\n>>> a = 1\n>>> b = 1.0\n>>> c = 1 + 2j\n>>> type(a)\n<class 'int'>\n>>> type(b)\n<class 'float'>\n>>> type(c)\n<class 'complex'>\n\\[\\langle S_t \\rangle =S_0 e^{-\\int_{0}^{t}\\beta  i_{\\tau} d \\tau}.\n\\langle S_t \\rangle =mst\nS_0=1-I_inicial\n-\\int_{0}^{t}\\beta  i_{\\tau} d \\tau=Int1\n\\]"
  },
  {
    "objectID": "section7.html",
    "href": "section7.html",
    "title": "Regresión líneal 3",
    "section": "",
    "text": "Sea los puntos \\(x_0=2.0\\), \\(x_1=1.2\\),…,\\(x_{20}=4.0\\), puntos igualmente espaciados entre el intervalo \\([2,4]\\) y sea el conjunto \\(y_i=1+x_i+x_1^2+\\cdots+x_i^{10}\\) para \\(0\\leq i\\leq 10\\). Obviamente el polinomio que que une a estos puntos es \\(P(x)=1+x+x^2+\\cdots+x^{10}\\). Supongamos que no conocemos el polinomio \\(P(x)\\), y lo queremos encontrar, de esta forma podemos decir que \\[P(x)=c_0+c_1x+\\cdots+c_{10}x^{10},\\] de esta forma podemos plantear el sistemas de ecuaciones\n\\[\\begin{pmatrix}\n1&x_0&x_0^2 &  & x^{10}_{0}\\\\\n\\vdots&\\vdots & \\vdots & & \\vdots\\\\\n1&x_{10}&x_{10}^2 &  & x^{10}_{20}\n\\end{pmatrix}\\begin{pmatrix}c_0\\\\\\vdots\\\\c_{10}\\end{pmatrix}=\\begin{pmatrix}y_0\\\\\\vdots\\\\y_{20}\\end{pmatrix}\\]\nSi resolvemos este sistema usando el método de ecuación normal. ¿Cuál es el error cometido? ¿Es una buena aproximación? REcuerde que la solución exacta es \\(c_i=1\\) para todo \\(i\\)."
  },
  {
    "objectID": "section6a.html",
    "href": "section6a.html",
    "title": "Regeresión lineal 2",
    "section": "",
    "text": "Vamos a calcular la regresión lienal simple de los siguientes datos y vamos a estudiar la conexión estadística de este algoritmo.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.special as sps\nfrom scipy import stats\nn=100\nx=np.linspace(0,10,n)\n\n\n\n\n\n\n\n\n# gamma distribution\nshape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\ngamma = np.random.default_rng().gamma(shape, scale,n)\ncount, bins, ignored = plt.hist(gamma, 50, density=True)\ny = bins**(shape-1)*(np.exp(-bins/scale) /  \n                     (sps.gamma(shape)*scale**shape))\nplt.plot(bins, y, linewidth=2, color='r')  \nplt.show()\n\n\n\n\n\n# uniforme distribution\nuniforme = np.random.default_rng().uniform(-1,1,n)\ncount, bins, ignored = plt.hist(uniforme, 15, density=True)\nplt.plot(bins, 0.5*np.ones_like(bins), linewidth=2, color='r')\nplt.show()\n\n\n\n\n\n\n#normal distribution\nmu, sigma = 0, 0.1 # mean and standard deviation\nnormal = np.random.default_rng().normal(mu, sigma, n)\ncount, bins, ignored = plt.hist(normal, 30, density=True)\nplt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n               np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n         linewidth=2, color='r')\nplt.show()\n\n\n\n\n\ndef regresion(x,y):\n    n=len(x)\n    #defineimos la matriz de coeficientes\n    A=np.zeros((n,2))\n    A[:,0]=x\n    A[:,1]=1\n    #definimos el vector de resultados\n    b=y\n    #Panteamos la ecuación normal\n    A_t=np.transpose(A)\n    A_t_A=np.dot(A_t,A) \n    A_t_b=np.dot(A_t,b)\n    #resolvemos el sistema de ecuaciones\n    # hacemos la factorizacion de Cholesky\n    L=np.linalg.cholesky(A_t_A)\n    #resolvemos el sistema triangular inferior\n    z=np.linalg.solve(L,A_t_b)\n    #resolvemos el sistema triangular superior\n    a=np.linalg.solve(np.transpose(L),z)\n    #calculamos el error\n    er=np.dot(A,a)-b\n    e=np.linalg.norm(er)\n    print(a)\n    print('el error de aproximación es',e)\n    return a,er\n    \ndef grafica(x,y,a):\n    # grafica la recta y los puntos\n    plt.plot(x,y,'o')\n    plt.plot(x,a[0]*x+a[1])\n    plt.plot(x,2.0*x+3.0,'r')\n    plt.show()\ndef grafica2(x,y,a):\n    # grafica la recta y los puntos\n    plt.plot(x,y,'o')\n    plt.plot(x,a[0]*x+a[1])\n    plt.show()\ndef graf_error(e):\n    #grafica el error\n    plt.hist(e,20)\n    plt.show()\n\n\n\n\nyn=2.0*x+3.0+normal\n\nan,en=regresion(x,yn)\ngrafica(x,yn,an)\ngraf_error(en)\n\n[1.99836929 2.99380631]\nel error de aproximación es 0.9580322491833362\n\n\n\n\n\n\n\n\n\nyg=2.0*x+3.0+gamma\n\nag,eg=regresion(x,yg)\ngrafica(x,yg,ag)\ngraf_error(eg)\n\n[1.98657722 6.6065886 ]\nel error de aproximación es 23.745895756254324\n\n\n\n\n\n\n\n\n\nyu=2.0*x+3.0+uniforme\nau,eu=regresion(x,yu)\ngrafica(x,yu,au)\ngraf_error(eu)\n\n[2.00446478 2.96599855]\nel error de aproximación es 6.0649662650873815\n\n\n\n\n\n\n\n\nNote que aquí estamos suponiendo que los errores se distribuyen normalmente, es decir, que la distribución de los errores es Gaussiana. Por eso cuando se usa la regresión lineal se asume las siguientes condiciones: * Los errores son independientes. * Los errores tienen la misma varianza. * Los errores son normales. * Los errores tienen media cero. * Los errores son homocedásticos.\nAdemás de esto, se puede hacer una conexión con la teoría de probabilidad y se puede calcular la máxima de la verosimilitud de los datos.\n\nEjemplo con datos reales.\nVamos a usar los datos de pingüinos, los cuales se encuentran pre-cargados en la librería searbosn y que nos permiten analizar la relación entre la longitud del pico y la masa corporal de los pingüinos. En la librearía seaborn podemos encontrar información de tres tipos de especies y en donde podemos analizar las siguientes variables: * bill_length_mm: longitud del pico en milímetros * bill_depth_mm: profunidad del pico en milímetros * flipper_length_mm: longitud de las alas en milímetros * body_mass_g: masa corporal en gramos * species: especie de pingüino\n\nimport numpy as np\nfrom scipy.stats import norm \nimport pandas as pd \nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n%matplotlib inline\nplt.rcParams['figure.figsize'] = (20, 10)\nplt.style.use('ggplot')\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\ndf = sns.load_dataset(\"penguins\")\ntype(df) # note que df es un objeto de tipo DataFrame  de pandas\n# para visualizar el encabezado del DataFrame\ndf.head()\n\n\n\n\n\n  \n    \n      \n      species\n      island\n      bill_length_mm\n      bill_depth_mm\n      flipper_length_mm\n      body_mass_g\n      sex\n    \n  \n  \n    \n      0\n      Adelie\n      Torgersen\n      39.1\n      18.7\n      181.0\n      3750.0\n      Male\n    \n    \n      1\n      Adelie\n      Torgersen\n      39.5\n      17.4\n      186.0\n      3800.0\n      Female\n    \n    \n      2\n      Adelie\n      Torgersen\n      40.3\n      18.0\n      195.0\n      3250.0\n      Female\n    \n    \n      3\n      Adelie\n      Torgersen\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      4\n      Adelie\n      Torgersen\n      36.7\n      19.3\n      193.0\n      3450.0\n      Female\n    \n  \n\n\n\n\n\n# para visualizar el tamaño del DataFrame\nprint('Total de elementos ',df.size)\n\n# para visualizar el número de filas y columnas del DataFrame\nprint('Número de filas y columnas',df.shape)\n\nTotal de elementos  2408\nNúmero de filas y columnas (344, 7)\n\n\n\n# para visualizar los datos estadísticos básicos  del DataFrame\ndf.describe()\n\n\n\n\n\n  \n    \n      \n      bill_length_mm\n      bill_depth_mm\n      flipper_length_mm\n      body_mass_g\n    \n  \n  \n    \n      count\n      342.000000\n      342.000000\n      342.000000\n      342.000000\n    \n    \n      mean\n      43.921930\n      17.151170\n      200.915205\n      4201.754386\n    \n    \n      std\n      5.459584\n      1.974793\n      14.061714\n      801.954536\n    \n    \n      min\n      32.100000\n      13.100000\n      172.000000\n      2700.000000\n    \n    \n      25%\n      39.225000\n      15.600000\n      190.000000\n      3550.000000\n    \n    \n      50%\n      44.450000\n      17.300000\n      197.000000\n      4050.000000\n    \n    \n      75%\n      48.500000\n      18.700000\n      213.000000\n      4750.000000\n    \n    \n      max\n      59.600000\n      21.500000\n      231.000000\n      6300.000000\n    \n  \n\n\n\n\n\n# aqui primero debemos mirar si hay datos faltantes\nprint(df.isnull()) # esto nos devuelve un DataFrame de booleanos\n# aqui imprime si el dato es  faltante o no\nprint(df.isnull().sum()) # esto nos devuelve la suma de los valores faltantes por columna\n\n     species  island  bill_length_mm  bill_depth_mm  flipper_length_mm  \\\n0      False   False           False          False              False   \n1      False   False           False          False              False   \n2      False   False           False          False              False   \n3      False   False            True           True               True   \n4      False   False           False          False              False   \n..       ...     ...             ...            ...                ...   \n339    False   False            True           True               True   \n340    False   False           False          False              False   \n341    False   False           False          False              False   \n342    False   False           False          False              False   \n343    False   False           False          False              False   \n\n     body_mass_g    sex  \n0          False  False  \n1          False  False  \n2          False  False  \n3           True   True  \n4          False  False  \n..           ...    ...  \n339         True   True  \n340        False  False  \n341        False  False  \n342        False  False  \n343        False  False  \n\n[344 rows x 7 columns]\nspecies               0\nisland                0\nbill_length_mm        2\nbill_depth_mm         2\nflipper_length_mm     2\nbody_mass_g           2\nsex                  11\ndtype: int64\n\n\n\n# para manipular la  base de datos debemos hacer una copia\n\ndf1 = df.copy()\n\n\n#vamos a buscar los datos faltantes en la columna \"body_mass_g\"\nprint(df1['body_mass_g'].isnull().sum()) # esto nos devuelve la suma de los valores faltantes por columna\n\n2\n\n\n\n#vamos a ver la fila de los datos faltantes en la columna \"body_mass_g\"\nprint(df1[df1['body_mass_g'].isnull()])\n\n    species     island  bill_length_mm  bill_depth_mm  flipper_length_mm  \\\n3    Adelie  Torgersen             NaN            NaN                NaN   \n339  Gentoo     Biscoe             NaN            NaN                NaN   \n\n     body_mass_g  sex  \n3            NaN  NaN  \n339          NaN  NaN  \n\n\nNecesitamos buscar alguna estrategia para estudiar los datos, por ejemplo, podemos rellenarlos con el promedio, o podemos omitir esos datos, o podemos usar la regresión lineal para estimar los valores faltantes (Note que para buscar una estrategia siempre es dependiente al problema). Para este caso vamos a omitir los datos faltantes.\n\n# eliminar la fila con los datos faltantes\ndf1.dropna(subset=['body_mass_g'], inplace=True)\nprint(df1.isnull().sum()) # esto nos devuelve la suma de los valores faltantes por columna\nprint(df1.shape) # para visualizar el número de filas y columnas del DataFrame\n\nspecies              0\nisland               0\nbill_length_mm       0\nbill_depth_mm        0\nflipper_length_mm    0\nbody_mass_g          0\nsex                  9\ndtype: int64\n(342, 7)\n\n\nVamos a estudiar la relación entre la longitud del pico y la masa corporal de los pingüinos. Para ello vamos a ver si existe una relación lineal entre estas dos variables. Una forma básica de estudiar dicha relación es hacer un primer gráfico de dispersión de los datos.\n\nby=df1[\"body_mass_g\"] # extraemos la columna body_mass_g\nbl=df1[\"bill_length_mm\"] # extraemos la columna bill_length_mm\n\n\n\n\n\nplt.scatter(by, bl)\nplt.xlabel(\"body mass grams\")\nplt.ylabel(\"bill length mm\")\nplt.title(\"Relationship between body mass and bill length\")\nplt.show()\n\n\n\n\n\n\nau,eu=regresion(by,bl)\nprint(eu)\ngrafica2(by,bl,au)\n\n[4.05141658e-03 2.68988724e+01]\nel error de aproximación es 81.02156608744191\n0      2.991685\n1      2.794255\n2     -0.234024\n4      4.176260\n5      2.386543\n         ...   \n338   -0.347901\n340   -0.251757\n341   -0.205482\n342    2.766239\n343   -1.123478\nName: bill_length_mm, Length: 342, dtype: float64\n\n\n\n\n\nAquí nos hacemos la pregunta, ¿los errores se distribuyen normalmente? Para responder esta pregunta podemos hacer un histograma de los errores.\n\ngraf_error(eu)\n\n\n\n\nPara verificar esto podemos hacer una prueba de hipótesis, para verificar si los errores de distribuyen normalmente, para esto usaremos la prueba de Shapiro-Wilk, la cual nos permite verificar si los datos se distribuyen normalmente o no, para esto usaremos la función shapiro de la librería scipy.stats, esta función nos devuelve un valor de p, el cual nos indica si los datos se distribuyen normalmente o no, si el valor de p es menor a 0.05, entonces los datos no se distribuyen normalmente, si el valor de p es mayor a 0.05, entonces no hay evidencia para rechazar la hipótesis.\n\nstats.shapiro(eu)\n\nShapiroResult(statistic=0.9543935060501099, pvalue=8.215727653748672e-09)\n\n\n\n\nREGRESIÓN MULTIPLE\nPodemos generalizar la regresión lineal simple para el caso de regresión líneal multiple, para esto debemos escoger variables independientes que sean linealmente independientes. En este caso, la regresión lineal multiple se puede escribir como:\n\\[y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\cdots + \\beta_p x_p + \\epsilon\\]\ny se puede escribir de la siguiente forma matricial: \\[y = A\\beta + \\epsilon\\]\nde esta forma tenemos que la aproximación de los parámetros \\(\\beta\\) se puede escribir como: \\[\\hat{\\beta} = (A^TA)^{-1}A^Ty\\]\nVamos a ve si existe una relación lineal entre la profundidad del pico se puede explicar desde la longitud del pico y la longitud de las alas. Para ello vamos a usar la regresión lineal multiple. Primero tenemos que mostrar que las tres variables son linealmente independientes estilísticamente, para ello vamos usar la covarianza y la correlación, (la correlación mide el ángulo entre las dos rectas que se obtienen al hacer la regresión lineal simple de los datos, cuando es 1 0 -1 los datos son colineales, es decir son dependientes). Para ello vamos a usar la función corr de la librería pandas.\nAntes de comenzar debemos revisar si los datos tienen valores faltantes\n\nprint(df1.isnull().sum()) # esto nos devuelve la suma de los valores faltantes por columna\n\nspecies              0\nisland               0\nbill_length_mm       0\nbill_depth_mm        0\nflipper_length_mm    0\nbody_mass_g          0\nsex                  9\ndtype: int64\n\n\n\n# Matriz de correlación para calcular la matriz de correlación en pandas usamos el método corr()\n\ndf1.corr()\n\n\n\n\n\n  \n    \n      \n      bill_length_mm\n      bill_depth_mm\n      flipper_length_mm\n      body_mass_g\n    \n  \n  \n    \n      bill_length_mm\n      1.000000\n      -0.235053\n      0.656181\n      0.595110\n    \n    \n      bill_depth_mm\n      -0.235053\n      1.000000\n      -0.583851\n      -0.471916\n    \n    \n      flipper_length_mm\n      0.656181\n      -0.583851\n      1.000000\n      0.871202\n    \n    \n      body_mass_g\n      0.595110\n      -0.471916\n      0.871202\n      1.000000\n    \n  \n\n\n\n\nNote que la correlación entre la masa del cuerpo y la longitud de las alas es 0.87 lo cual estadísticamente se “podría decir” que son colineales. Para estudiar este tipo de problemas se debe un análisis estadístico más profundo.\n\nimport numpy as np  \nimport matplotlib.pyplot as plt  \n#from mpl_toolkits import mplot3d  \nx = df1[\"bill_length_mm\"]\ny = df1[\"flipper_length_mm\"]\nz = df1[\"bill_depth_mm\"]\ndata = np.c_[x,y,z]\n\n  \n# Creating figures for the plot  \nfig = plt.figure(figsize = (10, 7))  \nax = plt.axes(projection =\"3d\")  \n  \n# Creating a plot using the random datasets   \nax.scatter3D(x, y, z, color = \"red\")  \nplt.title(\"Gráfica de los puntos\")  \n  \n# display the  plot  \nplt.show()  \n\n\n\n\n\ndef regresion(x,y,z):\n    n=len(x)\n    #defineimos la matriz de coeficientes\n    A=np.zeros((n,3))\n    A[:,0]=x\n    A[:,1]=y\n    A[:,2]=1\n    #definimos el vector de resultados\n    b=z\n    #Panteamos la ecuación normal\n    A_t=np.transpose(A)\n    A_t_A=np.dot(A_t,A) \n    A_t_b=np.dot(A_t,b)\n    #resolvemos el sistema de ecuaciones\n    # hacemos la factorizacion de Cholesky\n    L=np.linalg.cholesky(A_t_A)\n    #resolvemos el sistema triangular inferior\n    z=np.linalg.solve(L,A_t_b)\n    #resolvemos el sistema triangular superior\n    a=np.linalg.solve(np.transpose(L),z)\n    #calculamos el error\n    er=np.dot(A,a)-b\n    e=np.linalg.norm(er)\n    print(a)\n    print('el error de aproximación es',e)\n    return a,er\n\n    #grafica el error\n    plt.hist(e,20)\n    plt.show()\n\n\na,er=regresion(x,y,z)\ngraf_error(er)\n\n[ 0.09405042 -0.10595571 34.30840672]\nel error de aproximación es 28.728417944174634\n\n\n\n\n\n\n#from mpl_toolkits import mplot3d  \nx = df1[\"bill_length_mm\"]\ny = df1[\"flipper_length_mm\"]\nz = df1[\"bill_depth_mm\"]\ndata = np.c_[x,y,z]\nmn = np.min(data, axis=0)\nmx = np.max(data, axis=0)\nX,Y = np.meshgrid(np.linspace(mn[0], mx[0], 20), np.linspace(mn[1], mx[1], 20))\nZ = a[0]*X + a[1]*Y + a[2]  \n# Creating figures for the plot  \nfig = plt.figure(figsize = (10, 7))  \nax = plt.axes(projection =\"3d\")  \n  \n# Creating a plot using the random datasets   \nax.scatter3D(y, x, z, color = \"red\") \nax.plot_surface(Y, X, Z, rstride=1, cstride=1, alpha=0.3) \nplt.title(\"Gráfica de los puntos\")  \n  \n# display the  plot  \nplt.show()"
=======
>>>>>>> dd8470f2706310706559b8fd01854da5870b8036
  }
]